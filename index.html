<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TNTU Trainer v17 [Visual Graphs]</title>
    <style>
        :root {
            --primary: #00ffcc;
            --bg: #000000;
            --panel: #161616;
            --danger: #ff4444;
            --success: #00cc66;
            --pinch-color: #ff00ff;
        }

        body {
            margin: 0; padding: 0;
            background: var(--bg); color: #fff;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* --- –õ–û–ì –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø --- */
        #debug-console {
            position: fixed; top: 0; left: 0; width: 100%;
            background: rgba(0,0,0,0.8); color: yellow;
            font-family: monospace; font-size: 12px;
            padding: 5px; z-index: 9999; pointer-events: none;
            display: none; 
        }

        /* --- –ö–ê–ú–ï–†–ê --- */
        #camera-section {
            height: 35vh; /* –¢—Ä–æ—Ö–∏ –∑–º–µ–Ω—à–∏–≤, —â–æ–± –≤–ª—ñ–∑ –≥—Ä–∞—Ñ—ñ–∫ */
            display: flex; justify-content: center; align-items: center;
            background: #050505;
            position: relative;
        }

        #square-wrapper {
            position: relative;
            height: 95%; aspect-ratio: 1 / 1;
            border: 2px solid #333; border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0, 255, 204, 0.1);
            background: #000;
            display: flex; justify-content: center; align-items: center;
        }
        
        #square-wrapper.recording { border-color: var(--danger); box-shadow: 0 0 30px rgba(255, 68, 68, 0.4); }
        #square-wrapper.pinched { border-color: var(--pinch-color); box-shadow: 0 0 30px rgba(255, 0, 255, 0.4); }

        video, canvas {
            position: absolute; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
        }
        video { opacity: 0; z-index: 1; }
        canvas { z-index: 2; }

        #prediction-overlay {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); padding: 5px 15px; border-radius: 20px;
            font-weight: bold; font-size: 14px; color: var(--primary);
            z-index: 10; border: 1px solid var(--primary); white-space: nowrap;
        }

        #pinch-meter {
            position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6); padding: 2px 8px; border-radius: 8px;
            font-family: monospace; font-size: 11px; color: #fff; z-index: 10;
        }

        /* --- TOOLBAR --- */
        #toolbar {
            height: 40px; background: #222; border-top: 2px solid var(--primary);
            border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; z-index: 20;
        }

        .clear-btn {
            background: transparent; border: 1px solid #555; color: #ccc;
            padding: 4px 10px; border-radius: 6px; font-size: 10px; font-weight: bold;
            text-transform: uppercase; cursor: pointer;
        }
        .clear-btn:hover { border-color: var(--danger); color: var(--danger); }

        /* --- PANELS & BUTTONS --- */
        #bottom-panel {
            flex: 1; background: var(--panel); padding: 10px 15px;
            display: flex; flex-direction: column; gap: 8px; overflow-y: auto;
        }

        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

        button.record-btn {
            background: #2a2a2a; border: 1px solid #444; color: var(--primary);
            padding: 12px 10px; border-radius: 10px; font-size: 12px; font-weight: bold;
            text-transform: uppercase; cursor: pointer; width: 100%;
            display: flex; justify-content: space-between; align-items: center;
            transition: transform 0.1s;
        }
        button.record-btn:active { background: var(--danger); color: #fff; transform: scale(0.96); }
        
        .hint-text { font-size: 10px; color: #666; text-align: center; margin-top: 3px; }
        .count-badge { background: #000; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 11px; }

        .train-section {
            background: #222; border: 1px solid #333; border-radius: 10px; padding: 10px;
            display: flex; flex-direction: column; gap: 10px;
        }

        /* --- STYLED EPOCH CONTROL --- */
        .epoch-control {
            display: flex; align-items: center; justify-content: space-between;
            background: #111; padding: 5px; border-radius: 8px; border: 1px solid #444;
        }
        .epoch-btn {
            background: #333; border: none; color: #fff; width: 30px; height: 30px;
            border-radius: 5px; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        .epoch-btn:hover { background: #444; }
        
        .epoch-input-field {
            background: transparent; border: none; color: var(--primary);
            font-family: monospace; font-size: 16px; font-weight: bold;
            width: 60px; text-align: center; -moz-appearance: textfield;
        }
        .epoch-input-field:focus { outline: none; background: #222; border-radius: 4px; }

        /* --- CHART & PROGRESS --- */
        #progress-container {
            width: 100%; height: 6px; background: #111; border-radius: 3px;
            overflow: hidden; margin-top: 5px; display: none;
        }
        #progress-fill {
            height: 100%; width: 0%; background: var(--success); transition: width 0.2s ease;
        }
        
        #chart-container {
            position: relative; width: 100%; height: 60px; background: #000;
            border: 1px solid #333; border-radius: 4px; overflow: hidden;
            display: none; /* –°—Ö–æ–≤–∞–Ω–æ –ø–æ–∫–∏ –Ω–µ –ø–æ—á–∞–ª–æ—Å—å –Ω–∞–≤—á–∞–Ω–Ω—è */
        }
        #train-chart { width: 100%; height: 100%; }
        
        #train-status-text {
            font-size: 11px; color: #888; text-align: center; margin-top: 5px; height: 15px;
            display: flex; justify-content: space-between; padding: 0 5px;
        }

        .action-buttons { display: flex; gap: 10px; }
        .action-btn { 
            flex: 1; background: #004433; border: 1px solid var(--primary); color: #fff; 
            padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer; text-transform: uppercase; font-size: 14px;
        }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; background: #222; }

        #btn-restart {
            position: fixed; top: 10px; right: 10px; z-index: 100;
            background: rgba(255, 0, 0, 0.5); color: white; border: none;
            padding: 5px 10px; font-size: 10px; border-radius: 5px; cursor: pointer;
            display: none;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="debug-console"></div>
    <button id="btn-restart" onclick="location.reload()">Force Reload</button>

    <div id="camera-section">
        <div id="square-wrapper">
            <div id="prediction-overlay">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
            <div id="pinch-meter">DIST: 0.00</div>
            <video id="video" playsinline muted autoplay></video>
            <canvas id="output"></canvas>
        </div>
    </div>

    <div id="toolbar">
        <div id="status-log">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∫–∞–º–µ—Ä–∏...</div>
        <button class="clear-btn" onclick="clearAll()">üóë –û—á–∏—Å—Ç–∏—Ç–∏</button>
    </div>

    <div id="bottom-panel">
        
        <div class="grid-buttons">
            <div>
                <button class="record-btn" onmousedown="startRec(0)" onmouseup="stopRec()" ontouchstart="startRec(0)" ontouchend="stopRec()">
                    –°–ü–û–ö–Ü–ô <span id="c0" class="count-badge">0</span>
                </button>
                <div class="hint-text">–†—É–∫–∞ –≤—ñ–¥–∫—Ä–∏—Ç–∞</div>
            </div>
            <div>
                <button class="record-btn" onmousedown="startRec(1)" onmouseup="stopRec()" ontouchstart="startRec(1)" ontouchend="stopRec()">
                    –ó–ê–•–û–ü–õ–ï–ù–ù–Ø <span id="c1" class="count-badge">0</span>
                </button>
                <div class="hint-text">–©–∏–ø–æ–∫ / –ö—É–ª–∞–∫</div>
            </div>
            <div>
                <button class="record-btn" onmousedown="startRec(2)" onmouseup="stopRec()" ontouchstart="startRec(2)" ontouchend="stopRec()">
                    –û–ë–ï–†–¢–ê–ù–ù–Ø <span id="c2" class="count-badge">0</span>
                </button>
                <div class="hint-text">–¢—Ä–∏–∫—É—Ç–Ω–∏–∫</div>
            </div>
            <div>
                <button class="record-btn" onmousedown="startRec(3)" onmouseup="stopRec()" ontouchstart="startRec(3)" ontouchend="stopRec()">
                    –ú–ê–°–®–¢–ê–ë <span id="c3" class="count-badge">0</span>
                </button>
                <div class="hint-text">–õ–∞–π–∫ / –Ü–Ω—à–µ</div>
            </div>
        </div>

        <div class="train-section">
            
            <!-- –ö–µ—Ä—É–≤–∞–Ω–Ω—è –µ–ø–æ—Ö–∞–º–∏ -->
            <div class="epoch-control">
                <span style="font-size: 12px; color: #ccc; margin-left: 5px;">–ï–ø–æ—Ö–∏:</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button class="epoch-btn" onclick="adjustEpochs(-10)">-</button>
                    <input type="number" id="epoch-input" class="epoch-input-field" value="60" min="10" max="500" onchange="manualEpochUpdate(this.value)">
                    <button class="epoch-btn" onclick="adjustEpochs(10)">+</button>
                </div>
            </div>

            <!-- –ì–†–ê–§–Ü–ö –ü–†–û–¶–ï–°–£ -->
            <div id="chart-container">
                <canvas id="train-chart"></canvas>
            </div>

            <!-- –ü—Ä–æ–≥—Ä–µ—Å –±–∞—Ä -->
            <div>
                <div id="train-status-text">
                    <span>–ì–æ—Ç–æ–≤–∏–π –¥–æ –Ω–∞–≤—á–∞–Ω–Ω—è</span>
                    <span id="metric-text" style="color:var(--primary); display:none;">Loss: 0.00 | Acc: 0%</span>
                </div>
                <div id="progress-container">
                    <div id="progress-fill"></div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="action-btn" id="btn-train" onclick="train()">üöÄ –ù–∞–≤—á–∏—Ç–∏</button>
                <button class="action-btn" id="btn-save" onclick="download()" disabled>üíæ –°–∫–∞—á–∞—Ç–∏</button>
            </div>
        </div>
        
    </div>

<script>
    function log(msg, isError = false) {
        const overlay = document.getElementById('prediction-overlay');
        const status = document.getElementById('status-log');
        const consoleEl = document.getElementById('debug-console');
        
        console.log(`[SYS]: ${msg}`);
        overlay.innerText = msg;
        status.innerText = msg;
        
        if (isError) {
            overlay.style.color = 'red';
            overlay.style.borderColor = 'red';
            consoleEl.style.display = 'block';
            consoleEl.innerText += `ERR: ${msg}\n`;
            document.getElementById('btn-restart').style.display = 'block';
        }
    }

    const CLASSES = ['–°–ø–æ–∫—ñ–π', '–ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è', '–û–±–µ—Ä—Ç–∞–Ω–Ω—è', '–ú–∞—Å—à—Ç–∞–±'];
    const wrapper = document.getElementById('square-wrapper');
    const pinchMeter = document.getElementById('pinch-meter');

    const VIDEO = document.getElementById('video');
    const CANVAS = document.getElementById('output');
    const CTX = CANVAS.getContext('2d');
    
    function resizeCanvas() {
        const rect = wrapper.getBoundingClientRect();
        if (rect.width === 0) return;
        CANVAS.width = rect.width;
        CANVAS.height = rect.height;
    }
    window.addEventListener('resize', resizeCanvas);

    let isRecording = false;
    let currentLabel = -1;
    let data = { inputs: [], labels: [] };
    let counts = [0, 0, 0, 0];
    let model = null;
    let isTraining = false;
    let history = []; 
    const HISTORY_SIZE = 5;
    let hands = null;

    // --- CHART LOGIC ---
    let trainHistory = { loss: [], acc: [] };
    const chartCanvas = document.getElementById('train-chart');
    const chartCtx = chartCanvas.getContext('2d');

    function initChart() {
        // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π —Ä–æ–∑–º—ñ—Ä –∫–∞–Ω–≤–∞—Å—É
        chartCanvas.width = chartCanvas.clientWidth;
        chartCanvas.height = chartCanvas.clientHeight;
        trainHistory = { loss: [], acc: [] };
        chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
    }

    function drawChart() {
        const w = chartCanvas.width;
        const h = chartCanvas.height;
        const len = trainHistory.loss.length;
        if (len < 2) return;

        chartCtx.clearRect(0, 0, w, h);
        
        // –§–æ–Ω
        chartCtx.fillStyle = "#111";
        chartCtx.fillRect(0,0,w,h);
        
        // –°—ñ—Ç–∫–∞
        chartCtx.strokeStyle = "#333";
        chartCtx.lineWidth = 1;
        chartCtx.beginPath();
        chartCtx.moveTo(0, h/2); chartCtx.lineTo(w, h/2);
        chartCtx.stroke();

        // –§—É–Ω–∫—Ü—ñ—è –º–∞–ª—é–≤–∞–Ω–Ω—è –ª—ñ–Ω—ñ—ó
        function drawLine(dataArr, color, maxVal) {
            chartCtx.beginPath();
            chartCtx.strokeStyle = color;
            chartCtx.lineWidth = 2;
            
            const step = w / (epochCount - 1);
            
            for(let i=0; i<dataArr.length; i++) {
                const x = i * step;
                // –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è Y (0..maxVal -> h..0)
                let val = dataArr[i];
                if (val > maxVal) val = maxVal; // Clamping
                const y = h - (val / maxVal) * h;
                
                if (i===0) chartCtx.moveTo(x, y);
                else chartCtx.lineTo(x, y);
            }
            chartCtx.stroke();
        }

        // ACCURACY (Green, 0.0 - 1.0)
        drawLine(trainHistory.acc, "#00cc66", 1.0);
        
        // LOSS (Red, scaling roughly 0.0 - 1.5 usually)
        drawLine(trainHistory.loss, "#ff4444", 2.0);
    }

    // --- –ö–ï–†–£–í–ê–ù–ù–Ø –ï–ü–û–•–ê–ú–ò ---
    let epochCount = 60;
    
    function adjustEpochs(val) {
        if (isTraining) return;
        let el = document.getElementById('epoch-input');
        let current = parseInt(el.value) || 60;
        current += val;
        
        if (current < 10) current = 10;
        if (current > 500) current = 500;
        
        el.value = current;
        epochCount = current;
    }

    function manualEpochUpdate(val) {
        if (isTraining) return;
        let v = parseInt(val);
        if (isNaN(v) || v < 10) v = 10;
        if (v > 500) v = 500;
        document.getElementById('epoch-input').value = v;
        epochCount = v;
    }

    async function initCamera() {
        log("–ó–∞–ø–∏—Ç –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏...");
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                audio: false
            });
            VIDEO.srcObject = stream;
            VIDEO.onloadedmetadata = () => {
                log("–ö–∞–º–µ—Ä–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–∞.");
                resizeCanvas();
                VIDEO.play();
                initMediaPipe();
            };
        } catch (e) {
            log("–î–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ!", true);
            alert("–ü–æ–º–∏–ª–∫–∞ –∫–∞–º–µ—Ä–∏: " + e.message);
        }
    }

    function initMediaPipe() {
        log("–ó–∞–ø—É—Å–∫ AI —è–¥—Ä–∞...");
        try {
            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            requestAnimationFrame(renderLoop);
            log("–ì–æ—Ç–æ–≤–æ! –ü–æ–∫–∞–∂—ñ—Ç—å —Ä—É–∫—É");
        } catch (e) { log("–ü–æ–º–∏–ª–∫–∞ AI: " + e.message, true); }
    }

    async function renderLoop() {
        if (VIDEO.readyState >= 2) await hands.send({image: VIDEO});
        requestAnimationFrame(renderLoop);
    }

    function onResults(results) {
        CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
        CTX.drawImage(results.image, 0, 0, CANVAS.width, CANVAS.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            drawConnectors(CTX, lm, HAND_CONNECTIONS, {color: '#00ffcc', lineWidth: 2});
            drawLandmarks(CTX, lm, {color: '#ff0000', lineWidth: 1, radius: 3});
            
            const dist = calculatePinchDist(lm);
            pinchMeter.innerText = `DIST: ${dist.toFixed(3)}`;
            
            if (dist < 0.05 && !isRecording) wrapper.classList.add('pinched');
            else wrapper.classList.remove('pinched');

            updateUIState(lm);
        } else {
            updateUIState(null);
        }
    }

    function updateUIState(lm) {
        const overlay = document.getElementById('prediction-overlay');
        if (!lm) {
            overlay.innerText = "–ù–µ–º–∞—î —Ä—É–∫–∏";
            overlay.style.color = "#888";
            overlay.style.borderColor = "#444";
            return;
        }
        if (isRecording) {
            record(lm);
            wrapper.classList.add('recording');
            wrapper.classList.remove('pinched');
            overlay.innerText = "REC: " + CLASSES[currentLabel];
            overlay.style.color = "#ff4444";
            overlay.style.borderColor = "#ff4444";
        } else {
            wrapper.classList.remove('recording');
            if (model && !isTraining) {
                predict(lm);
            } else {
                overlay.innerText = "–†—É–∫–∞ –≤–∏—è–≤–ª–µ–Ω–∞";
                overlay.style.color = "#00ffcc";
                overlay.style.borderColor = "#00ffcc";
            }
        }
    }

    function calculatePinchDist(lm) {
        const dx = lm[8].x - lm[4].x;
        const dy = lm[8].y - lm[4].y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    function processLandmarks(landmarks) {
        const wrist = landmarks[0];
        const flat = [];
        let max = 0;
        for (let p of landmarks) {
            let x = p.x - wrist.x;
            let y = p.y - wrist.y;
            let z = p.z - wrist.z;
            flat.push(x, y, z);
            max = Math.max(max, Math.abs(x), Math.abs(y), Math.abs(z));
        }
        return flat.map(v => v / (max + 1e-6));
    }

    function startRec(id) { 
        if(isTraining) return;
        isRecording = true; 
        currentLabel = id; 
        if(navigator.vibrate) navigator.vibrate(40);
    }
    function stopRec() { isRecording = false; }

    function record(lm) {
        data.inputs.push(processLandmarks(lm));
        data.labels.push(currentLabel);
        counts[currentLabel]++;
        document.getElementById(`c${currentLabel}`).innerText = counts[currentLabel];
    }

    function clearAll() {
        if(!confirm("–í–∏–¥–∞–ª–∏—Ç–∏ –≤—Å—ñ –¥–∞–Ω—ñ?")) return;
        data = { inputs: [], labels: [] };
        counts = [0,0,0,0];
        for(let i=0; i<4; i++) document.getElementById(`c${i}`).innerText = 0;
        if(model) { model.dispose(); model = null; }
        document.getElementById('btn-save').disabled = true;
        document.getElementById('progress-container').style.display = 'none';
        document.getElementById('chart-container').style.display = 'none';
        document.getElementById('metric-text').style.display = 'none';
        document.getElementById('train-status-text').firstElementChild.innerText = "–ì–æ—Ç–æ–≤–∏–π –¥–æ –Ω–∞–≤—á–∞–Ω–Ω—è";
        log("–î–∞–Ω—ñ –æ—á–∏—â–µ–Ω–æ");
    }

    async function train() {
        if (data.inputs.length < 10) { alert("–ú–∞–ª–æ –¥–∞–Ω–∏—Ö!"); return; }
        
        isTraining = true;
        document.getElementById('btn-train').disabled = true;
        document.getElementById('btn-save').disabled = true;
        document.getElementById('epoch-input').disabled = true;

        const manualEpochs = parseInt(document.getElementById('epoch-input').value);
        if (manualEpochs) epochCount = manualEpochs;

        // UI SETUP
        const progContainer = document.getElementById('progress-container');
        const progFill = document.getElementById('progress-fill');
        const statusText = document.getElementById('train-status-text').firstElementChild;
        const metricText = document.getElementById('metric-text');
        const chartContainer = document.getElementById('chart-container');
        
        progContainer.style.display = 'block';
        chartContainer.style.display = 'block';
        metricText.style.display = 'block';
        progFill.style.width = '0%';
        progFill.style.backgroundColor = "#00cc66";
        
        initChart(); // Clear old chart
        
        const inputs = tf.tensor2d(data.inputs);
        const labels = tf.oneHot(tf.tensor1d(data.labels, 'int32'), 4);

        model = tf.sequential();
        model.add(tf.layers.dense({units: 64, activation: 'relu', inputShape: [63]}));
        model.add(tf.layers.dropout({rate: 0.2}));
        model.add(tf.layers.dense({units: 32, activation: 'relu'}));
        model.add(tf.layers.dense({units: 4, activation: 'softmax'}));

        model.compile({optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ['accuracy']});

        log(`–°—Ç–∞—Ä—Ç –Ω–∞–≤—á–∞–Ω–Ω—è...`);
        
        await model.fit(inputs, labels, {
            epochs: epochCount,
            batchSize: 16,
            callbacks: {
                onEpochEnd: (e, l) => { 
                    const pct = Math.round(((e + 1) / epochCount) * 100);
                    progFill.style.width = `${pct}%`;
                    
                    // Update Text
                    statusText.innerText = `–ï–ø–æ—Ö–∞ ${e+1}/${epochCount}`;
                    metricText.innerText = `Loss: ${l.loss.toFixed(3)} | Acc: ${(l.acc*100).toFixed(0)}%`;
                    
                    // Update Chart
                    trainHistory.loss.push(l.loss);
                    trainHistory.acc.push(l.acc);
                    drawChart();

                    if (e % 10 === 0) log(`E:${e+1} Acc:${(l.acc*100).toFixed(0)}%`); 
                }
            }
        });

        isTraining = false;
        log("–ù–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ!");
        statusText.innerText = "–ì–æ—Ç–æ–≤–æ! –ú–æ–∂–Ω–∞ —Å–∫–∞—á—É–≤–∞—Ç–∏.";
        progFill.style.backgroundColor = "#00ffcc";
        
        document.getElementById('btn-train').disabled = false;
        document.getElementById('btn-save').disabled = false;
        document.getElementById('epoch-input').disabled = false;
        inputs.dispose(); labels.dispose();
    }

    function predict(lm) {
        tf.tidy(() => {
            const input = tf.tensor2d([processLandmarks(lm)]);
            const pred = model.predict(input);
            const idx = pred.argMax(1).dataSync()[0];
            const conf = pred.dataSync()[idx];

            history.push(idx);
            if(history.length > HISTORY_SIZE) history.shift();
            const counts = {}; history.forEach(h => counts[h] = (counts[h] || 0) + 1);
            const stableIdx = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);

            const overlay = document.getElementById('prediction-overlay');
            overlay.innerText = `${CLASSES[stableIdx]} ${(conf*100).toFixed(0)}%`;
            const color = conf > 0.8 ? "#00ffcc" : "#ffff00";
            overlay.style.color = color;
            overlay.style.borderColor = color;
        });
    }

    async function download() {
        const name = "gesture-model"; 
        await model.save(`downloads://${name}`);
        log(`–ó–±–µ—Ä–µ–∂–µ–Ω–æ —è–∫: ${name}`);
    }

    window.onload = initCamera;
</script>
</body>
</html>
