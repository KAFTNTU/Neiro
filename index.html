<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TNTU Trainer v7</title>
    <style>
        :root {
            --primary: #00ffcc;
            --bg: #000000;
            --panel: #1a1a1a;
            --danger: #ff4444;
            --success: #00cc66;
            --pinch-color: #ff00ff;
        }

        body {
            margin: 0; padding: 0;
            background: var(--bg); color: #fff;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* --- –ö–ê–ú–ï–†–ê --- */
        #camera-section {
            flex: 1;
            display: flex; justify-content: center; align-items: center;
            position: relative; background: #050505;
        }

        #square-wrapper {
            position: relative;
            width: 90vw; max-width: 400px;
            aspect-ratio: 1 / 1;
            border: 2px solid #333; border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.1);
            transition: border-color 0.2s;
        }
        #square-wrapper.recording { border-color: var(--danger); box-shadow: 0 0 30px rgba(255, 68, 68, 0.4); }
        #square-wrapper.pinched { border-color: var(--pinch-color); box-shadow: 0 0 30px rgba(255, 0, 255, 0.4); }

        video, canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
        }

        #prediction-overlay {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); padding: 5px 15px; border-radius: 20px;
            font-weight: bold; font-size: 16px; color: var(--primary);
            z-index: 10; border: 1px solid var(--primary); white-space: nowrap;
        }

        #pinch-meter {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6); padding: 2px 10px; border-radius: 10px;
            font-family: monospace; font-size: 12px; color: #fff; z-index: 10;
        }

        /* --- –ù–ò–ñ–ù–Ø –ü–ê–ù–ï–õ–¨ --- */
        #bottom-panel {
            height: auto; min-height: 40vh;
            background: var(--panel);
            border-top: 2px solid var(--primary);
            border-radius: 25px 25px 0 0;
            padding: 20px;
            display: flex; flex-direction: column; gap: 15px;
            overflow-y: auto;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
        }

        h2 { margin: 0; font-size: 14px; color: #888; text-transform: uppercase; letter-spacing: 1px; }

        .setting-box {
            background: #222; padding: 10px 15px; border-radius: 12px; border: 1px solid #444;
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;
        }

        .epoch-input {
            background: #111; border: 1px solid var(--primary); color: #fff;
            padding: 5px; width: 80px; text-align: center; border-radius: 5px;
            font-weight: bold; font-size: 16px; font-family: monospace;
        }

        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 5px; }
        
        button {
            background: #2a2a2a; border: 1px solid #444; color: var(--primary);
            padding: 15px; border-radius: 12px; font-size: 13px; font-weight: bold;
            text-transform: uppercase; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            transition: all 0.2s;
        }
        button:active { transform: scale(0.98); }
        button.record-btn:active { background: var(--danger); color: #fff; border-color: var(--danger); }
        button:disabled { opacity: 0.5; filter: grayscale(1); cursor: not-allowed; }

        .action-buttons { display: flex; gap: 10px; margin-top: 5px; }
        .action-btn { flex: 1; background: #004433; border-color: var(--primary); color: #fff; justify-content: center; }
        
        .count-badge { background: #000; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 11px; }
        #status-log { font-size: 11px; color: #666; text-align: center; margin-top: 5px; font-family: monospace; }
        
        .hint-text { font-size: 10px; color: #666; margin-top: 2px; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="camera-section">
        <div id="square-wrapper">
            <div id="prediction-overlay">–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è...</div>
            <div id="pinch-meter">DIST: 0.00</div>
            <video id="video" playsinline></video>
            <canvas id="output"></canvas>
        </div>
    </div>

    <div id="bottom-panel">
        
        <div>
            <h2>1. –ó–±—ñ—Ä –¥–∞–Ω–∏—Ö</h2>
            <div class="grid-buttons">
                <!-- IDLE -->
                <div>
                    <button class="record-btn" onmousedown="startRec(0)" onmouseup="stopRec()" ontouchstart="startRec(0)" ontouchend="stopRec()">
                        IDLE (Open) <span id="c0" class="count-badge">0</span>
                    </button>
                    <div class="hint-text">–†—É–∫–∞ –≤—ñ–¥–∫—Ä–∏—Ç–∞ –∞–±–æ –Ω–∞–≤–æ–¥–∏—Ç—å</div>
                </div>

                <!-- GRAB -->
                <div>
                    <button class="record-btn" onmousedown="startRec(1)" onmouseup="stopRec()" ontouchstart="startRec(1)" ontouchend="stopRec()">
                        GRAB (Pinch) <span id="c1" class="count-badge">0</span>
                    </button>
                    <div class="hint-text">–ü–∞–ª—å—Ü—ñ –∑'—î–¥–Ω–∞–Ω—ñ (—â–∏–ø–æ–∫)</div>
                </div>

                <!-- ROTATE -->
                <div>
                    <button class="record-btn" onmousedown="startRec(2)" onmouseup="stopRec()" ontouchstart="startRec(2)" ontouchend="stopRec()">
                        ROTATE <span id="c2" class="count-badge">0</span>
                    </button>
                    <div class="hint-text">–¢—Ä–∏–∫—É—Ç–Ω–∏–∫ –ø–∞–ª—å—Ü—è–º–∏</div>
                </div>

                <!-- ZOOM -->
                <div>
                    <button class="record-btn" onmousedown="startRec(3)" onmouseup="stopRec()" ontouchstart="startRec(3)" ontouchend="stopRec()">
                        ZOOM <span id="c3" class="count-badge">0</span>
                    </button>
                    <div class="hint-text">–õ–∞–π–∫ –∞–±–æ —ñ–Ω—à–∏–π –∂–µ—Å—Ç</div>
                </div>
            </div>
            <div style="text-align: right; margin-top: 5px;">
                <button onclick="clearAll()" style="padding: 5px 10px; font-size: 10px; width: auto; display: inline-block; background: transparent; border: 1px solid #444; color: #666;">–û—á–∏—Å—Ç–∏—Ç–∏</button>
            </div>
        </div>

        <div>
            <h2>2. –ù–∞–≤—á–∞–Ω–Ω—è</h2>
            
            <div class="setting-box" style="margin-top: 10px; justify-content: flex-start; gap: 15px;">
                <label for="epochs-input" style="font-size: 14px; font-weight: bold;">–ï–ø–æ—Ö–∏ (Epochs):</label>
                <input type="number" id="epochs-input" class="epoch-input" value="100" min="1" max="1000000">
            </div>

            <div id="status-log">–ì–æ—Ç–æ–≤–æ</div>
            <div class="action-buttons">
                <button class="action-btn" id="btn-train" onclick="train()">üöÄ Start</button>
                <button class="action-btn" id="btn-save" onclick="download()" disabled>üíæ Save</button>
            </div>
        </div>
    </div>

<script>
    const CLASSES = ['Idle', 'Grab', 'Rotate', 'Zoom'];
    const wrapper = document.getElementById('square-wrapper');
    const predOverlay = document.getElementById('prediction-overlay');
    const pinchMeter = document.getElementById('pinch-meter');
    const statusLog = document.getElementById('status-log');
    
    let isRecording = false;
    let currentLabel = -1;
    let data = { inputs: [], labels: [] };
    let counts = [0, 0, 0, 0];
    let model = null;
    let isTraining = false;
    let history = []; 
    const HISTORY_SIZE = 5;

    const VIDEO = document.getElementById('video');
    const CANVAS = document.getElementById('output');
    const CTX = CANVAS.getContext('2d');

    // --- MEDIAPIPE INIT ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    
    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è (–±–µ–∑ –ø–µ—Ä–µ–º–∏–∫–∞—á–∞)
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
        CTX.drawImage(results.image, 0, 0, CANVAS.width, CANVAS.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            // 1. –ú–∞–ª—é—î–º–æ
            drawConnectors(CTX, lm, HAND_CONNECTIONS, {color: '#00ffcc', lineWidth: 2});
            drawLandmarks(CTX, lm, {color: '#ff0000', lineWidth: 1, radius: 3});

            // 2. –†–∞—Ö—É—î–º–æ –≤—ñ–¥—Å—Ç–∞–Ω—å (—â–∏–ø–æ–∫) –¥–ª—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó
            const dist = calculatePinchDist(lm);
            pinchMeter.innerText = `DIST: ${dist.toFixed(3)}`;
            
            // –í—ñ–∑—É–∞–ª—å–Ω–∏–π –µ—Ñ–µ–∫—Ç "–º–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ–≥–æ" —â–∏–ø–∫–∞ ( < 0.05)
            if (dist < 0.05 && !isRecording) {
                wrapper.classList.add('pinched');
            } else {
                wrapper.classList.remove('pinched');
            }

            // 3. –õ–æ–≥—ñ–∫–∞
            if (isRecording) {
                record(lm);
                wrapper.classList.add('recording');
                wrapper.classList.remove('pinched');
                predOverlay.innerText = "–ó–ê–ü–ò–°: " + CLASSES[currentLabel];
                predOverlay.style.color = "#ff4444";
                predOverlay.style.borderColor = "#ff4444";
            } else {
                wrapper.classList.remove('recording');
                if (model && !isTraining) {
                    predict(lm);
                } else {
                    predOverlay.innerText = "–†—É–∫–∞ –≤–∏—è–≤–ª–µ–Ω–∞";
                    predOverlay.style.color = "#00ffcc";
                    predOverlay.style.borderColor = "#00ffcc";
                }
            }
        } else {
            predOverlay.innerText = "–ü–æ–∫–∞–∂—ñ—Ç—å —Ä—É–∫—É";
            predOverlay.style.color = "#888";
            predOverlay.style.borderColor = "#444";
        }
    });

    const camera = new Camera(VIDEO, {
        onFrame: async () => { await hands.send({image: VIDEO}); },
        width: 640, height: 480
    });
    camera.start();

    // --- MATH HELPER ---
    function calculatePinchDist(lm) {
        // –í—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –≤–∫–∞–∑—ñ–≤–Ω–∏–º (8) —Ç–∞ –≤–µ–ª–∏–∫–∏–º (4)
        const dx = lm[8].x - lm[4].x;
        const dy = lm[8].y - lm[4].y;
        // z –Ω–µ –≤—Ä–∞—Ö–æ–≤—É—î–º–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç–∏ 2D –ø—Ä–æ–µ–∫—Ü—ñ—ó, –∞–±–æ –º–æ–∂–Ω–∞ –≤—Ä–∞—Ö—É–≤–∞—Ç–∏
        return Math.sqrt(dx*dx + dy*dy);
    }

    // --- DATA PROCESSING ---
    function processLandmarks(landmarks) {
        const wrist = landmarks[0];
        const flat = [];
        let max = 0;
        for (let p of landmarks) {
            let x = p.x - wrist.x;
            let y = p.y - wrist.y;
            let z = p.z - wrist.z;
            flat.push(x, y, z);
            max = Math.max(max, Math.abs(x), Math.abs(y), Math.abs(z));
        }
        return flat.map(v => v / (max + 1e-6));
    }

    // --- RECORDING ---
    function startRec(id) { 
        if(isTraining) return;
        isRecording = true; 
        currentLabel = id; 
        if(navigator.vibrate) navigator.vibrate(50);
    }
    function stopRec() { isRecording = false; }

    function record(lm) {
        data.inputs.push(processLandmarks(lm));
        data.labels.push(currentLabel);
        counts[currentLabel]++;
        document.getElementById(`c${currentLabel}`).innerText = counts[currentLabel];
    }

    function clearAll() {
        data = { inputs: [], labels: [] };
        counts = [0,0,0,0];
        for(let i=0; i<4; i++) document.getElementById(`c${i}`).innerText = 0;
        if(model) { model.dispose(); model = null; }
        document.getElementById('btn-save').disabled = true;
        statusLog.innerText = "–î–∞–Ω—ñ –æ—á–∏—â–µ–Ω–æ";
    }

    // --- TRAINING ---
    async function train() {
        if (data.inputs.length < 10) { alert("–ú–∞–ª–æ –¥–∞–Ω–∏—Ö!"); return; }
        
        const epochsInput = document.getElementById('epochs-input');
        let userEpochs = parseInt(epochsInput.value);
        if (!userEpochs || userEpochs < 1) userEpochs = 50;

        isTraining = true;
        document.getElementById('btn-train').disabled = true;
        
        const inputs = tf.tensor2d(data.inputs);
        const labels = tf.oneHot(tf.tensor1d(data.labels, 'int32'), 4);

        model = tf.sequential();
        model.add(tf.layers.dense({units: 64, activation: 'relu', inputShape: [63]}));
        model.add(tf.layers.dropout({rate: 0.2}));
        model.add(tf.layers.dense({units: 32, activation: 'relu'}));
        model.add(tf.layers.dense({units: 4, activation: 'softmax'}));

        model.compile({optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ['accuracy']});

        statusLog.innerText = `–°—Ç–∞—Ä—Ç –Ω–∞–≤—á–∞–Ω–Ω—è (${userEpochs} –µ–ø–æ—Ö)...`;
        
        await model.fit(inputs, labels, {
            epochs: userEpochs,
            batchSize: 16,
            callbacks: {
                onEpochEnd: (e, l) => { 
                    if (e % Math.ceil(userEpochs / 20) === 0 || e === userEpochs - 1) {
                        statusLog.innerText = `–ï–ø–æ—Ö–∞ ${e+1}/${userEpochs}: –¢–æ—á–Ω—ñ—Å—Ç—å ${(l.acc*100).toFixed(0)}%`; 
                    }
                }
            }
        });

        isTraining = false;
        statusLog.innerText = "–ì–æ—Ç–æ–≤–æ! –ú–æ–∂–Ω–∞ —Ç–µ—Å—Ç—É–≤–∞—Ç–∏.";
        document.getElementById('btn-train').disabled = false;
        document.getElementById('btn-save').disabled = false;
        inputs.dispose(); labels.dispose();
    }

    function predict(lm) {
        tf.tidy(() => {
            const input = tf.tensor2d([processLandmarks(lm)]);
            const pred = model.predict(input);
            const idx = pred.argMax(1).dataSync()[0];
            const conf = pred.dataSync()[idx];

            history.push(idx);
            if(history.length > HISTORY_SIZE) history.shift();
            const counts = {}; history.forEach(h => counts[h] = (counts[h] || 0) + 1);
            const stableIdx = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);

            predOverlay.innerText = `${CLASSES[stableIdx]} ${(conf*100).toFixed(0)}%`;
            // –ö–æ–ª—ñ—Ä –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –≤–ø–µ–≤–Ω–µ–Ω–æ—Å—Ç—ñ
            const color = conf > 0.8 ? "#00ffcc" : "#ffff00";
            predOverlay.style.color = color;
            predOverlay.style.borderColor = color;
        });
    }

    async function download() {
        const now = new Date();
        const name = `TNTU_Model_${String(now.getHours()).padStart(2,'0')}-${String(now.getMinutes()).padStart(2,'0')}-${String(now.getSeconds()).padStart(2,'0')}`;
        await model.save(`downloads://${name}`);
        statusLog.innerText = `–ó–±–µ—Ä–µ–∂–µ–Ω–æ: ${name}`;
    }
</script>
</body>
</html>


