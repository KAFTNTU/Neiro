      <!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TNTU Trainer v10 [Compact]</title>
    <style>
        :root {
            --primary: #00ffcc;
            --bg: #000000;
            --panel: #161616;
            --danger: #ff4444;
            --success: #00cc66;
            --pinch-color: #ff00ff;
        }

        body {
            margin: 0; padding: 0;
            background: var(--bg); color: #fff;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* --- 1. –ö–ê–ú–ï–†–ê (–í–µ—Ä—Ö–Ω—ñ 40%) --- */
        #camera-section {
            height: 40vh; /* –§—ñ–∫—Å–æ–≤–∞–Ω–∞ –≤–∏—Å–æ—Ç–∞ */
            display: flex; justify-content: center; align-items: center;
            background: #050505;
            position: relative;
        }

        #square-wrapper {
            position: relative;
            height: 90%; /* –ú–∞–π–∂–µ –Ω–∞ –≤—Å—é –≤–∏—Å–æ—Ç—É —Å–µ–∫—Ü—ñ—ó */
            aspect-ratio: 1 / 1; /* –ö–≤–∞–¥—Ä–∞—Ç */
            border: 2px solid #333; border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.1);
            transition: border-color 0.2s;
            display: flex; justify-content: center; align-items: center;
        }
        
        #square-wrapper.recording { border-color: var(--danger); box-shadow: 0 0 30px rgba(255, 68, 68, 0.4); }
        #square-wrapper.pinched { border-color: var(--pinch-color); box-shadow: 0 0 30px rgba(255, 0, 255, 0.4); }

        video, canvas {
            position: absolute; height: 100%; width: auto; min-width: 100%; 
            left: 50%; transform: translateX(50%) scaleX(-1); 
            object-fit: cover; 
        }

        #prediction-overlay {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); padding: 4px 12px; border-radius: 20px;
            font-weight: bold; font-size: 14px; color: var(--primary);
            z-index: 10; border: 1px solid var(--primary); white-space: nowrap;
        }

        #pinch-meter {
            position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6); padding: 2px 8px; border-radius: 8px;
            font-family: monospace; font-size: 11px; color: #fff; z-index: 10;
        }

        /* --- 2. –ü–ê–ù–ï–õ–¨ –Ü–ù–°–¢–†–£–ú–ï–ù–¢–Ü–í (–°–º—É–∂–∫–∞ –ø–æ—Å–µ—Ä–µ–¥–∏–Ω—ñ) --- */
        #toolbar {
            height: 50px;
            background: #222;
            border-top: 2px solid var(--primary);
            border-bottom: 1px solid #333;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px;
            z-index: 20;
        }

        #status-log {
            font-family: monospace; font-size: 12px; color: #aaa;
        }

        .clear-btn {
            background: transparent; border: 1px solid #555; color: #888;
            padding: 6px 15px; border-radius: 6px; font-size: 11px; text-transform: uppercase;
            cursor: pointer; transition: 0.2s;
        }
        .clear-btn:hover { border-color: var(--danger); color: var(--danger); }

        /* --- 3. –ù–ò–ñ–ù–Ø –ü–ê–ù–ï–õ–¨ (–†–µ—à—Ç–∞ –µ–∫—Ä–∞–Ω—É) --- */
        #bottom-panel {
            flex: 1; /* –ó–∞–π–º–∞—î —Ä–µ—à—Ç—É –º—ñ—Å—Ü—è */
            background: var(--panel);
            padding: 15px 20px;
            display: flex; flex-direction: column; gap: 10px;
            overflow-y: auto;
        }

        h2 { margin: 0 0 5px 0; font-size: 13px; color: #666; text-transform: uppercase; letter-spacing: 1px; }

        /* –°—ñ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ */
        .grid-buttons { 
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px; 
        }

        /* –°—Ç–∏–ª—å –∫–Ω–æ–ø–æ–∫ –∑–∞–ø–∏—Å—É */
        .btn-wrapper { position: relative; }
        
        button.record-btn {
            background: #252525; border: 1px solid #444; color: var(--primary);
            padding: 15px 10px; border-radius: 10px; font-size: 13px; font-weight: bold;
            text-transform: uppercase; cursor: pointer; width: 100%;
            display: flex; justify-content: space-between; align-items: center;
            transition: all 0.1s;
        }
        button.record-btn:active { background: var(--danger); color: #fff; border-color: var(--danger); transform: scale(0.98); }
        
        .hint-text { 
            font-size: 10px; color: #555; text-align: center; margin-top: 2px; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        .count-badge { background: #000; padding: 2px 5px; border-radius: 4px; font-family: monospace; font-size: 11px; }

        /* –°–µ–∫—Ü—ñ—è –Ω–∞–≤—á–∞–Ω–Ω—è */
        .train-section {
            background: #222; border: 1px solid #333; border-radius: 10px; padding: 10px;
            display: flex; flex-direction: column; gap: 8px;
        }

        .epoch-row { display: flex; align-items: center; gap: 10px; font-size: 13px; color: #ccc; }
        .epoch-input {
            background: #111; border: 1px solid #555; color: #fff;
            padding: 4px 8px; width: 70px; text-align: center; border-radius: 5px;
            font-weight: bold; font-family: monospace;
        }

        .action-buttons { display: flex; gap: 8px; }
        .action-btn { 
            flex: 1; background: #004433; border: 1px solid var(--primary); color: #fff; 
            padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer;
            text-transform: uppercase; font-size: 14px;
        }
        .action-btn:disabled { opacity: 0.3; filter: grayscale(1); }
        .action-btn:active { background: var(--primary); color: #000; }

    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- 1. –ö–ê–ú–ï–†–ê -->
    <div id="camera-section">
        <div id="square-wrapper">
            <div id="prediction-overlay">–ó–∞–ø—É—Å–∫...</div>
            <div id="pinch-meter">DIST: 0.00</div>
            <video id="video" playsinline></video>
            <canvas id="output"></canvas>
        </div>
    </div>

    <!-- 2. –ü–ê–ù–ï–õ–¨ –Ü–ù–°–¢–†–£–ú–ï–ù–¢–Ü–í (–¢—É—Ç —Ç–µ–ø–µ—Ä –∫–Ω–æ–ø–∫–∞ –û—á–∏—Å—Ç–∏—Ç–∏) -->
    <div id="toolbar">
        <div id="status-log">–ì–æ—Ç–æ–≤–æ –¥–æ —Ä–æ–±–æ—Ç–∏</div>
        <button class="clear-btn" onclick="clearAll()">üóë –û—á–∏—Å—Ç–∏—Ç–∏</button>
    </div>

    <!-- 3. –ö–ù–û–ü–ö–ò –¢–ê –ù–ê–í–ß–ê–ù–ù–Ø -->
    <div id="bottom-panel">
        
        <!-- –°–µ–∫—Ü—ñ—è –ó–±–æ—Ä—É -->
        <div class="grid-buttons">
            <div class="btn-wrapper">
                <button class="record-btn" onmousedown="startRec(0)" onmouseup="stopRec()" ontouchstart="startRec(0)" ontouchend="stopRec()">
                    IDLE <span id="c0" class="count-badge">0</span>
                </button>
                <div class="hint-text">–†—É–∫–∞ –≤—ñ–¥–∫—Ä–∏—Ç–∞</div>
            </div>

            <div class="btn-wrapper">
                <button class="record-btn" onmousedown="startRec(1)" onmouseup="stopRec()" ontouchstart="startRec(1)" ontouchend="stopRec()">
                    GRAB <span id="c1" class="count-badge">0</span>
                </button>
                <div class="hint-text">–©–∏–ø–æ–∫ / –ö—É–ª–∞–∫</div>
            </div>

            <div class="btn-wrapper">
                <button class="record-btn" onmousedown="startRec(2)" onmouseup="stopRec()" ontouchstart="startRec(2)" ontouchend="stopRec()">
                    ROTATE <span id="c2" class="count-badge">0</span>
                </button>
                <div class="hint-text">–¢—Ä–∏–∫—É—Ç–Ω–∏–∫</div>
            </div>

            <div class="btn-wrapper">
                <button class="record-btn" onmousedown="startRec(3)" onmouseup="stopRec()" ontouchstart="startRec(3)" ontouchend="stopRec()">
                    ZOOM <span id="c3" class="count-badge">0</span>
                </button>
                <div class="hint-text">–õ–∞–π–∫ / –Ü–Ω—à–µ</div>
            </div>
        </div>

        <!-- –°–µ–∫—Ü—ñ—è –ù–∞–≤—á–∞–Ω–Ω—è -->
        <div class="train-section">
            <div class="epoch-row">
                <span>–ï–ø–æ—Ö–∏ (Epochs):</span>
                <input type="number" id="epochs-input" class="epoch-input" value="60" min="10">
            </div>
            
            <div class="action-buttons">
                <button class="action-btn" id="btn-train" onclick="train()">üöÄ –ù–∞–≤—á–∏—Ç–∏</button>
                <button class="action-btn" id="btn-save" onclick="download()" disabled>üíæ –°–∫–∞—á–∞—Ç–∏</button>
            </div>
        </div>

    </div>

<script>
    const CLASSES = ['Idle', 'Grab', 'Rotate', 'Zoom'];
    const wrapper = document.getElementById('square-wrapper');
    const predOverlay = document.getElementById('prediction-overlay');
    const pinchMeter = document.getElementById('pinch-meter');
    const statusLog = document.getElementById('status-log');
    
    let isRecording = false;
    let currentLabel = -1;
    let data = { inputs: [], labels: [] };
    let counts = [0, 0, 0, 0];
    let model = null;
    let isTraining = false;
    let history = []; 
    const HISTORY_SIZE = 5;

    const VIDEO = document.getElementById('video');
    const CANVAS = document.getElementById('output');
    const CTX = CANVAS.getContext('2d');

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1, // Full model for accuracy
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
        CTX.drawImage(results.image, 0, 0, CANVAS.width, CANVAS.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            drawConnectors(CTX, lm, HAND_CONNECTIONS, {color: '#00ffcc', lineWidth: 2});
            drawLandmarks(CTX, lm, {color: '#ff0000', lineWidth: 1, radius: 3});

            const dist = calculatePinchDist(lm);
            pinchMeter.innerText = `DIST: ${dist.toFixed(2)}`;
            
            if (dist < 0.05 && !isRecording) {
                wrapper.classList.add('pinched');
            } else {
                wrapper.classList.remove('pinched');
            }

            if (isRecording) {
                record(lm);
                wrapper.classList.add('recording');
                wrapper.classList.remove('pinched');
                predOverlay.innerText = "REC: " + CLASSES[currentLabel];
                predOverlay.style.color = "#ff4444";
                predOverlay.style.borderColor = "#ff4444";
            } else {
                wrapper.classList.remove('recording');
                if (model && !isTraining) {
                    predict(lm);
                } else {
                    predOverlay.innerText = "–†—É–∫–∞ —î";
                    predOverlay.style.color = "#00ffcc";
                    predOverlay.style.borderColor = "#00ffcc";
                }
            }
        } else {
            predOverlay.innerText = "–ù–µ–º–∞—î —Ä—É–∫–∏";
            predOverlay.style.color = "#888";
            predOverlay.style.borderColor = "#444";
        }
    });

    const camera = new Camera(VIDEO, {
        onFrame: async () => { await hands.send({image: VIDEO}); },
        width: 640, height: 480
    });
    camera.start();

    function calculatePinchDist(lm) {
        const dx = lm[8].x - lm[4].x;
        const dy = lm[8].y - lm[4].y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    function processLandmarks(landmarks) {
        const wrist = landmarks[0];
        const flat = [];
        let max = 0;
        for (let p of landmarks) {
            let x = p.x - wrist.x;
            let y = p.y - wrist.y;
            let z = p.z - wrist.z;
            flat.push(x, y, z);
            max = Math.max(max, Math.abs(x), Math.abs(y), Math.abs(z));
        }
        return flat.map(v => v / (max + 1e-6));
    }

    function startRec(id) { 
        if(isTraining) return;
        isRecording = true; 
        currentLabel = id; 
        if(navigator.vibrate) navigator.vibrate(40);
    }
    function stopRec() { isRecording = false; }

    function record(lm) {
        data.inputs.push(processLandmarks(lm));
        data.labels.push(currentLabel);
        counts[currentLabel]++;
        document.getElementById(`c${currentLabel}`).innerText = counts[currentLabel];
    }

    function clearAll() {
        if(!confirm("–í–∏–¥–∞–ª–∏—Ç–∏ –≤—Å—ñ –∑–∞–ø–∏—Å–∞–Ω—ñ –¥–∞–Ω—ñ?")) return;
        data = { inputs: [], labels: [] };
        counts = [0,0,0,0];
        for(let i=0; i<4; i++) document.getElementById(`c${i}`).innerText = 0;
        if(model) { model.dispose(); model = null; }
        document.getElementById('btn-save').disabled = true;
        statusLog.innerText = "–î–∞–Ω—ñ –æ—á–∏—â–µ–Ω–æ";
    }

    async function train() {
        if (data.inputs.length < 10) { alert("–ú–∞–ª–æ –¥–∞–Ω–∏—Ö!"); return; }
        
        const epochsInput = document.getElementById('epochs-input');
        let userEpochs = parseInt(epochsInput.value);
        if (!userEpochs || userEpochs < 1) userEpochs = 50;

        isTraining = true;
        document.getElementById('btn-train').disabled = true;
        
        const inputs = tf.tensor2d(data.inputs);
        const labels = tf.oneHot(tf.tensor1d(data.labels, 'int32'), 4);

        model = tf.sequential();
        model.add(tf.layers.dense({units: 64, activation: 'relu', inputShape: [63]}));
        model.add(tf.layers.dropout({rate: 0.2}));
        model.add(tf.layers.dense({units: 32, activation: 'relu'}));
        model.add(tf.layers.dense({units: 4, activation: 'softmax'}));

        model.compile({optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ['accuracy']});

        statusLog.innerText = `–ù–∞–≤—á–∞–Ω–Ω—è...`;
        
        await model.fit(inputs, labels, {
            epochs: userEpochs,
            batchSize: 16,
            callbacks: {
                onEpochEnd: (e, l) => { 
                    if (e % Math.ceil(userEpochs / 10) === 0 || e === userEpochs - 1) {
                        statusLog.innerText = `E:${e+1} Acc:${(l.acc*100).toFixed(0)}%`; 
                    }
                }
            }
        });

        isTraining = false;
        statusLog.innerText = "–ì–æ—Ç–æ–≤–æ!";
        document.getElementById('btn-train').disabled = false;
        document.getElementById('btn-save').disabled = false;
        inputs.dispose(); labels.dispose();
    }

    function predict(lm) {
        tf.tidy(() => {
            const input = tf.tensor2d([processLandmarks(lm)]);
            const pred = model.predict(input);
            const idx = pred.argMax(1).dataSync()[0];
            const conf = pred.dataSync()[idx];

            history.push(idx);
            if(history.length > HISTORY_SIZE) history.shift();
            const counts = {}; history.forEach(h => counts[h] = (counts[h] || 0) + 1);
            const stableIdx = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);

            predOverlay.innerText = `${CLASSES[stableIdx]} ${(conf*100).toFixed(0)}%`;
            const color = conf > 0.8 ? "#00ffcc" : "#ffff00";
            predOverlay.style.color = color;
            predOverlay.style.borderColor = color;
        });
    }

    async function download() {
        const now = new Date();
        const name = `TNTU_Model_${String(now.getHours()).padStart(2,'0')}-${String(now.getMinutes()).padStart(2,'0')}-${String(now.getSeconds()).padStart(2,'0')}`;
        await model.save(`downloads://${name}`);
        statusLog.innerText = `–ó–±–µ—Ä–µ–∂–µ–Ω–æ: ${name}`;
    }
</script>
</body>
</html>


