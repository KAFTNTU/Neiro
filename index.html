<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TNTU Trainer v14 [Bulletproof]</title>
    <style>
        :root {
            --primary: #00ffcc;
            --bg: #000000;
            --panel: #161616;
            --danger: #ff4444;
            --success: #00cc66;
            --pinch-color: #ff00ff;
        }

        body {
            margin: 0; padding: 0;
            background: var(--bg); color: #fff;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* --- –õ–û–ì –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø (–©–æ–± –±–∞—á–∏—Ç–∏ –ø–æ–º–∏–ª–∫–∏) --- */
        #debug-console {
            position: fixed; top: 0; left: 0; width: 100%;
            background: rgba(0,0,0,0.8); color: yellow;
            font-family: monospace; font-size: 12px;
            padding: 5px; z-index: 9999; pointer-events: none;
            display: none; /* –ü–æ–∫–∞–∑—É—î–º–æ —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ —î –ø–æ–º–∏–ª–∫–∏ */
        }

        /* --- –ö–ê–ú–ï–†–ê --- */
        #camera-section {
            height: 40vh;
            display: flex; justify-content: center; align-items: center;
            background: #050505;
            position: relative;
        }

        #square-wrapper {
            position: relative;
            height: 95%; aspect-ratio: 1 / 1;
            border: 2px solid #333; border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0, 255, 204, 0.1);
            background: #000;
            display: flex; justify-content: center; align-items: center;
        }
        
        #square-wrapper.recording { border-color: var(--danger); box-shadow: 0 0 30px rgba(255, 68, 68, 0.4); }
        #square-wrapper.pinched { border-color: var(--pinch-color); box-shadow: 0 0 30px rgba(255, 0, 255, 0.4); }

        /* –í–Ü–î–ï–û –¢–ê –ö–ê–ù–í–ê–° */
        video, canvas {
            position: absolute;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        /* –í—ñ–¥–µ–æ –º–∞—î –±—É—Ç–∏ –≤–∏–¥–∏–º–∏–º –¥–ª—è DOM, –∞–ª–µ –ø—Ä–æ–∑–æ—Ä–∏–º –¥–ª—è –æ–∫–∞ */
        video { opacity: 0; z-index: 1; }
        canvas { z-index: 2; }

        #prediction-overlay {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); padding: 5px 15px; border-radius: 20px;
            font-weight: bold; font-size: 14px; color: var(--primary);
            z-index: 10; border: 1px solid var(--primary); white-space: nowrap;
        }

        #pinch-meter {
            position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6); padding: 2px 8px; border-radius: 8px;
            font-family: monospace; font-size: 11px; color: #fff; z-index: 10;
        }

        /* --- TOOLBAR --- */
        #toolbar {
            height: 50px; background: #222; border-top: 2px solid var(--primary);
            border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; z-index: 20;
        }

        .clear-btn {
            background: transparent; border: 1px solid #555; color: #ccc;
            padding: 6px 14px; border-radius: 6px; font-size: 11px; font-weight: bold;
            text-transform: uppercase; cursor: pointer;
        }
        .clear-btn:hover { border-color: var(--danger); color: var(--danger); }

        /* --- BUTTONS --- */
        #bottom-panel {
            flex: 1; background: var(--panel); padding: 15px 20px;
            display: flex; flex-direction: column; gap: 10px; overflow-y: auto;
        }

        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }

        button.record-btn {
            background: #2a2a2a; border: 1px solid #444; color: var(--primary);
            padding: 15px 10px; border-radius: 10px; font-size: 13px; font-weight: bold;
            text-transform: uppercase; cursor: pointer; width: 100%;
            display: flex; justify-content: space-between; align-items: center;
        }
        button.record-btn:active { background: var(--danger); color: #fff; transform: scale(0.96); }
        
        .hint-text { font-size: 10px; color: #666; text-align: center; margin-top: 3px; }
        .count-badge { background: #000; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 11px; }

        .train-section {
            background: #222; border: 1px solid #333; border-radius: 10px; padding: 10px;
            display: flex; flex-direction: column; gap: 10px;
        }

        .epoch-wrapper { display: flex; align-items: center; gap: 10px; font-size: 13px; color: #ccc; }
        .epoch-input {
            background: #111; border: 1px solid #555; color: #fff;
            padding: 5px; width: 70px; text-align: center; border-radius: 5px;
            font-weight: bold; font-family: monospace;
        }

        .action-buttons { display: flex; gap: 10px; }
        .action-btn { 
            flex: 1; background: #004433; border: 1px solid var(--primary); color: #fff; 
            padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer; text-transform: uppercase; font-size: 14px;
        }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; background: #222; }

        /* –ö–Ω–æ–ø–∫–∞ —Ä–µ—Å—Ç–∞—Ä—Ç—É –Ω–∞ –≤–∏–ø–∞–¥–æ–∫ –∑–∞–≤–∏—Å–∞–Ω–Ω—è */
        #btn-restart {
            position: fixed; top: 10px; right: 10px; z-index: 100;
            background: rgba(255, 0, 0, 0.5); color: white; border: none;
            padding: 5px 10px; font-size: 10px; border-radius: 5px; cursor: pointer;
            display: none;
        }

    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="debug-console"></div>
    <button id="btn-restart" onclick="location.reload()">Force Reload</button>

    <div id="camera-section">
        <div id="square-wrapper">
            <div id="prediction-overlay">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
            <div id="pinch-meter">DIST: 0.00</div>
            <video id="video" playsinline muted autoplay></video>
            <canvas id="output"></canvas>
        </div>
    </div>

    <div id="toolbar">
        <div id="status-log">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∫–∞–º–µ—Ä–∏...</div>
        <button class="clear-btn" onclick="clearAll()">üóë –û—á–∏—Å—Ç–∏—Ç–∏</button>
    </div>

    <div id="bottom-panel">
        
        <div class="grid-buttons">
            <div>
                <button class="record-btn" onmousedown="startRec(0)" onmouseup="stopRec()" ontouchstart="startRec(0)" ontouchend="stopRec()">
                    IDLE <span id="c0" class="count-badge">0</span>
                </button>
                <div class="hint-text">–†—É–∫–∞ –≤—ñ–¥–∫—Ä–∏—Ç–∞</div>
            </div>
            <div>
                <button class="record-btn" onmousedown="startRec(1)" onmouseup="stopRec()" ontouchstart="startRec(1)" ontouchend="stopRec()">
                    GRAB <span id="c1" class="count-badge">0</span>
                </button>
                <div class="hint-text">–©–∏–ø–æ–∫ / –ö—É–ª–∞–∫</div>
            </div>
            <div>
                <button class="record-btn" onmousedown="startRec(2)" onmouseup="stopRec()" ontouchstart="startRec(2)" ontouchend="stopRec()">
                    ROTATE <span id="c2" class="count-badge">0</span>
                </button>
                <div class="hint-text">–¢—Ä–∏–∫—É—Ç–Ω–∏–∫</div>
            </div>
            <div>
                <button class="record-btn" onmousedown="startRec(3)" onmouseup="stopRec()" ontouchstart="startRec(3)" ontouchend="stopRec()">
                    ZOOM <span id="c3" class="count-badge">0</span>
                </button>
                <div class="hint-text">–õ–∞–π–∫ / –Ü–Ω—à–µ</div>
            </div>
        </div>

        <div class="train-section">
            <div class="epoch-wrapper">
                <span>–ï–ø–æ—Ö–∏:</span>
                <input type="number" id="epochs-input" class="epoch-input" value="60" min="10">
            </div>
            <div class="action-buttons">
                <button class="action-btn" id="btn-train" onclick="train()">üöÄ –ù–∞–≤—á–∏—Ç–∏</button>
                <button class="action-btn" id="btn-save" onclick="download()" disabled>üíæ –°–∫–∞—á–∞—Ç–∏</button>
            </div>
        </div>
        
    </div>

<script>
    // --- –î–Ü–ê–ì–ù–û–°–¢–ò–ö–ê ---
    function log(msg, isError = false) {
        const overlay = document.getElementById('prediction-overlay');
        const status = document.getElementById('status-log');
        const consoleEl = document.getElementById('debug-console');
        
        console.log(`[SYS]: ${msg}`);
        overlay.innerText = msg;
        status.innerText = msg;
        
        if (isError) {
            overlay.style.color = 'red';
            overlay.style.borderColor = 'red';
            consoleEl.style.display = 'block';
            consoleEl.innerText += `ERR: ${msg}\n`;
            document.getElementById('btn-restart').style.display = 'block';
        }
    }

    const CLASSES = ['Idle', 'Grab', 'Rotate', 'Zoom'];
    const wrapper = document.getElementById('square-wrapper');
    const pinchMeter = document.getElementById('pinch-meter');

    const VIDEO = document.getElementById('video');
    const CANVAS = document.getElementById('output');
    const CTX = CANVAS.getContext('2d');
    
    // –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è —Ä–æ–∑–º—ñ—Ä—ñ–≤
    function resizeCanvas() {
        const rect = wrapper.getBoundingClientRect();
        if (rect.width === 0) return; // –©–µ –Ω–µ –≥–æ—Ç–æ–≤–æ
        CANVAS.width = rect.width;
        CANVAS.height = rect.height;
    }
    window.addEventListener('resize', resizeCanvas);

    // --- –ó–ú–Ü–ù–ù–Ü ---
    let isRecording = false;
    let currentLabel = -1;
    let data = { inputs: [], labels: [] };
    let counts = [0, 0, 0, 0];
    let model = null;
    let isTraining = false;
    let history = []; 
    const HISTORY_SIZE = 5;
    let hands = null;
    let cameraStream = null;

    // --- 1. –ü–†–Ø–ú–ò–ô –ó–ê–ü–£–°–ö –ö–ê–ú–ï–†–ò (–ë–ï–ó wrapper'—ñ–≤) ---
    async function initCamera() {
        log("–ó–∞–ø–∏—Ç –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏...");
        try {
            // –ó–∞–ø–∏—Ç—É—î–º–æ –ø–æ—Ç—ñ–∫
            cameraStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'user',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                },
                audio: false
            });
            
            VIDEO.srcObject = cameraStream;
            
            // –ß–µ–∫–∞—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–µ—Ç–∞–¥–∞–Ω–∏—Ö
            VIDEO.onloadedmetadata = () => {
                log("–ö–∞–º–µ—Ä–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–∞. –°—Ç–∞—Ä—Ç...");
                resizeCanvas();
                VIDEO.play();
                initMediaPipe(); // –¢—ñ–ª—å–∫–∏ —Ç–µ–ø–µ—Ä –∑–∞–ø—É—Å–∫–∞—î–º–æ AI
            };

        } catch (e) {
            log("–î–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ!", true);
            alert("–ü–æ–º–∏–ª–∫–∞ –∫–∞–º–µ—Ä–∏: " + e.message + "\n–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –¥–æ–∑–≤–æ–ª–∏ –±—Ä–∞—É–∑–µ—Ä–∞.");
        }
    }

    // --- 2. MEDIAPIPE (–¢–Ü–õ–¨–ö–ò –ü–Ü–°–õ–Ø –ö–ê–ú–ï–†–ò) ---
    function initMediaPipe() {
        log("–ó–∞–ø—É—Å–∫ AI —è–¥—Ä–∞...");
        try {
            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
            
            // –ó–∞–ø—É—Å–∫–∞—î–º–æ –Ω–∞—à –≤–ª–∞—Å–Ω–∏–π —Ü–∏–∫–ª (–±–µ–∑ CameraUtils)
            requestAnimationFrame(renderLoop);
            log("–ì–æ—Ç–æ–≤–æ! –ü–æ–∫–∞–∂—ñ—Ç—å —Ä—É–∫—É");

        } catch (e) {
            log("–ü–æ–º–∏–ª–∫–∞ AI: " + e.message, true);
        }
    }

    // --- 3. –ì–û–õ–û–í–ù–ò–ô –¶–ò–ö–õ ---
    async function renderLoop() {
        // –Ø–∫—â–æ –≤—ñ–¥–µ–æ –Ω–∞ –ø–∞—É–∑—ñ –∞–±–æ –Ω–µ –≥–æ—Ç–æ–≤–µ - –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
        if (VIDEO.readyState >= 2) {
            await hands.send({image: VIDEO});
        }
        requestAnimationFrame(renderLoop);
    }

    // --- –û–ë–†–û–ë–ö–ê –†–ï–ó–£–õ–¨–¢–ê–¢–Ü–í ---
    function onResults(results) {
        // –û—á–∏—Å—Ç–∫–∞
        CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
        
        // –ú–∞–ª—é–≤–∞–Ω–Ω—è –≤—ñ–¥–µ–æ
        CTX.drawImage(results.image, 0, 0, CANVAS.width, CANVAS.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            drawConnectors(CTX, lm, HAND_CONNECTIONS, {color: '#00ffcc', lineWidth: 2});
            drawLandmarks(CTX, lm, {color: '#ff0000', lineWidth: 1, radius: 3});

            const dist = calculatePinchDist(lm);
            pinchMeter.innerText = `DIST: ${dist.toFixed(3)}`;
            
            if (dist < 0.05 && !isRecording) wrapper.classList.add('pinched');
            else wrapper.classList.remove('pinched');

            updateUIState(lm);
        } else {
            updateUIState(null);
        }
    }

    function updateUIState(lm) {
        const overlay = document.getElementById('prediction-overlay');
        
        if (!lm) {
            overlay.innerText = "–ù–µ–º–∞—î —Ä—É–∫–∏";
            overlay.style.color = "#888";
            overlay.style.borderColor = "#444";
            return;
        }

        if (isRecording) {
            record(lm);
            wrapper.classList.add('recording');
            wrapper.classList.remove('pinched');
            overlay.innerText = "REC: " + CLASSES[currentLabel];
            overlay.style.color = "#ff4444";
            overlay.style.borderColor = "#ff4444";
        } else {
            wrapper.classList.remove('recording');
            if (model && !isTraining) {
                predict(lm);
            } else {
                overlay.innerText = "–†—É–∫–∞ –≤–∏—è–≤–ª–µ–Ω–∞";
                overlay.style.color = "#00ffcc";
                overlay.style.borderColor = "#00ffcc";
            }
        }
    }

    // --- –õ–û–ì–Ü–ö–ê –î–û–î–ê–¢–ö–£ ---
    function calculatePinchDist(lm) {
        const dx = lm[8].x - lm[4].x;
        const dy = lm[8].y - lm[4].y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    function processLandmarks(landmarks) {
        const wrist = landmarks[0];
        const flat = [];
        let max = 0;
        for (let p of landmarks) {
            let x = p.x - wrist.x;
            let y = p.y - wrist.y;
            let z = p.z - wrist.z;
            flat.push(x, y, z);
            max = Math.max(max, Math.abs(x), Math.abs(y), Math.abs(z));
        }
        return flat.map(v => v / (max + 1e-6));
    }

    function startRec(id) { 
        if(isTraining) return;
        isRecording = true; 
        currentLabel = id; 
        if(navigator.vibrate) navigator.vibrate(40);
    }
    function stopRec() { isRecording = false; }

    function record(lm) {
        data.inputs.push(processLandmarks(lm));
        data.labels.push(currentLabel);
        counts[currentLabel]++;
        document.getElementById(`c${currentLabel}`).innerText = counts[currentLabel];
    }

    function clearAll() {
        if(!confirm("–í–∏–¥–∞–ª–∏—Ç–∏ –≤—Å—ñ –¥–∞–Ω—ñ?")) return;
        data = { inputs: [], labels: [] };
        counts = [0,0,0,0];
        for(let i=0; i<4; i++) document.getElementById(`c${i}`).innerText = 0;
        if(model) { model.dispose(); model = null; }
        document.getElementById('btn-save').disabled = true;
        log("–î–∞–Ω—ñ –æ—á–∏—â–µ–Ω–æ");
    }

    async function train() {
        if (data.inputs.length < 10) { alert("–ú–∞–ª–æ –¥–∞–Ω–∏—Ö!"); return; }
        const epochsInput = document.getElementById('epochs-input');
        let userEpochs = parseInt(epochsInput.value) || 50;

        isTraining = true;
        document.getElementById('btn-train').disabled = true;
        
        const inputs = tf.tensor2d(data.inputs);
        const labels = tf.oneHot(tf.tensor1d(data.labels, 'int32'), 4);

        model = tf.sequential();
        model.add(tf.layers.dense({units: 64, activation: 'relu', inputShape: [63]}));
        model.add(tf.layers.dropout({rate: 0.2}));
        model.add(tf.layers.dense({units: 32, activation: 'relu'}));
        model.add(tf.layers.dense({units: 4, activation: 'softmax'}));

        model.compile({optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ['accuracy']});

        log(`–ù–∞–≤—á–∞–Ω–Ω—è...`);
        await model.fit(inputs, labels, {
            epochs: userEpochs,
            batchSize: 16,
            callbacks: {
                onEpochEnd: (e, l) => { 
                    if (e % Math.ceil(userEpochs / 10) === 0 || e === userEpochs - 1) {
                        log(`E:${e+1} Acc:${(l.acc*100).toFixed(0)}%`); 
                    }
                }
            }
        });

        isTraining = false;
        log("–ì–æ—Ç–æ–≤–æ!");
        document.getElementById('btn-train').disabled = false;
        document.getElementById('btn-save').disabled = false;
        inputs.dispose(); labels.dispose();
    }

    function predict(lm) {
        tf.tidy(() => {
            const input = tf.tensor2d([processLandmarks(lm)]);
            const pred = model.predict(input);
            const idx = pred.argMax(1).dataSync()[0];
            const conf = pred.dataSync()[idx];

            history.push(idx);
            if(history.length > HISTORY_SIZE) history.shift();
            const counts = {}; history.forEach(h => counts[h] = (counts[h] || 0) + 1);
            const stableIdx = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);

            const overlay = document.getElementById('prediction-overlay');
            overlay.innerText = `${CLASSES[stableIdx]} ${(conf*100).toFixed(0)}%`;
            const color = conf > 0.8 ? "#00ffcc" : "#ffff00";
            overlay.style.color = color;
            overlay.style.borderColor = color;
        });
    }

    async function download() {
        const now = new Date();
        const name = `TNTU_Model_${String(now.getHours()).padStart(2,'0')}-${String(now.getMinutes()).padStart(2,'0')}-${String(now.getSeconds()).padStart(2,'0')}`;
        await model.save(`downloads://${name}`);
        log(`–ó–±–µ—Ä–µ–∂–µ–Ω–æ: ${name}`);
    }

    // --- –ó–ê–ü–£–°–ö ---
    window.onload = initCamera;

</script>
</body>
</html>
